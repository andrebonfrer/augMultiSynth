% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/build_Xy_for_unit.R
\name{build_Xy_for_unit}
\alias{build_Xy_for_unit}
\title{Build stacked pre-treatment design for one treated unit}
\usage{
build_Xy_for_unit(
  Y_list,
  treat_time,
  j,
  donors,
  L,
  standardize_outcomes = FALSE,
  eps_sd = 1e-08
)
}
\arguments{
\item{Y_list}{A list of outcome matrices, one per outcome.
Each element must be a numeric matrix of dimension \code{N x T} with units
in rows and time in columns. All outcomes must have identical \code{N} and \code{T}.}

\item{treat_time}{Numeric vector of length \code{N}. \code{treat_time[i]}
is the first treated period for unit \code{i}. Use \code{Inf} for never-treated units.}

\item{j}{Integer. Index of the treated unit for which to build the design.}

\item{donors}{Integer vector. Indices of donor units eligible for unit \code{j}.}

\item{L}{Integer. Number of pre-treatment periods to use. Uses periods
\code{(treat_time[j]-L):(treat_time[j]-1)}.}

\item{standardize_outcomes}{Logical. If \code{TRUE}, standardizes each outcome block
using donor-pool pre-treatment mean and SD (computed over donors and \code{pre_times}),
then applies the same transformation to treated and donor pre-treatment values.
This helps when outcomes are on different scales or have outcome-specific intercepts.}

\item{eps_sd}{Small positive scalar used as a floor for the SD to avoid division by
near-zero values when standardizing.}
}
\value{
A list with components:
\describe{
\item{X}{Numeric matrix of dimension \code{(M*L) x Nd}, stacked donor pre outcomes.}
\item{y}{Numeric vector of length \code{M*L}, stacked treated unit pre outcomes.}
\item{pre_times}{Integer vector of pre-treatment time indices used.}
\item{scales}{List of length \code{M} with per-outcome \code{mean} and \code{sd} used
when \code{standardize_outcomes=TRUE}. If \code{FALSE}, returns mean=0 and sd=1.}
}
}
\description{
Constructs the stacked (multi-outcome) pre-treatment design matrix and target
vector for a single treated unit \code{j}. This is used to fit donor weights
that minimize pre-treatment mismatch across multiple outcomes simultaneously.
}
\details{
The function stacks pre-treatment observations over outcomes and time:
\itemize{
\item \code{y} is length \code{M*L}, containing treated unit \code{j}'s pre-treatment
values for each outcome and time
\item \code{X} is a \code{(M*L) x Nd} matrix where each column is a donor unit's
stacked pre-treatment values over outcomes and time
}

When \code{standardize_outcomes=TRUE}, each outcome \code{m} is transformed as
\deqn{Y^{(m)} \leftarrow (Y^{(m)} - \bar Y^{(m)}_{\text{donor,pre}})/s^{(m)}_{\text{donor,pre}}}
where the mean and SD are computed using donor units and pre-treatment periods only,
avoiding post-treatment leakage.
}
\examples{
N <- 50; T <- 60
Y1 <- matrix(rnorm(N*T), N, T)
Y2 <- matrix(10 + 5*rnorm(N*T), N, T)   # different scale/level
treat_time <- rep(Inf, N); treat_time[1:10] <- 40
donors <- which(treat_time > 50)
out <- build_Xy_for_unit(
  list(Y1, Y2), treat_time, j = 1, donors = donors, L = 10,
  standardize_outcomes = TRUE
)
str(out)

}
