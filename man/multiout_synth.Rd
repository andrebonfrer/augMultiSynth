% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiout_synth.R
\name{multiout_synth}
\alias{multiout_synth}
\title{Multi-outcome synthetic control with unit-level treatment effects}
\usage{
multiout_synth(
  Y_list,
  treat_time,
  treated_units = NULL,
  L,
  K,
  max_donors = 1000,
  screen_outcome = 1,
  screen_method = c("cor", "mse"),
  lambda = 0.001,
  solver = c("fw"),
  pooled_adjustment = FALSE,
  nu = 0,
  verbose = FALSE,
  standardize_outcomes = FALSE,
  outcome_weights = NULL,
  time_weights = NULL,
  intercept = c("none", "global", "outcome"),
  eps_sd = 1e-08,
  parallel = FALSE,
  n_cores = max(1L, parallel::detectCores() - 1L),
  backend = c("auto", "fork", "psock")
)
}
\arguments{
\item{Y_list}{List of outcome matrices, each of dimension \code{N x T}. All outcomes
must share the same \code{N} and \code{T}. Units are in rows; time periods are in columns.}

\item{treat_time}{Numeric vector of length \code{N}. \code{treat_time[i]} is the first treated
period for unit \code{i}. Use \code{Inf} for never-treated units.}

\item{treated_units}{Optional integer vector of treated unit indices to estimate. Defaults
to all units with finite \code{treat_time}.}

\item{L}{Integer. Number of pre-treatment periods used to fit donor weights. For treated
unit \code{j}, pre-periods are \code{(treat_time[j]-L):(treat_time[j]-1)}.}

\item{K}{Integer. Maximum event time. Returns unit-level effects for \code{k = 0,...,K}.}

\item{max_donors}{Integer. Maximum donor set size after screening. Defaults to \code{1000}.}

\item{screen_outcome}{Integer. Index of the outcome in \code{Y_list} used for donor screening.
Defaults to \code{1}.}

\item{screen_method}{Donor screening method. One of \code{"cor"} or \code{"mse"}.}

\item{lambda}{Nonnegative scalar ridge penalty applied to donor weights in the simplex solver.}

\item{solver}{Solver choice. Currently \code{"fw"} (Frank--Wolfe) for simplex-constrained
ridge regression.}

\item{pooled_adjustment}{Logical. If \code{TRUE}, estimates a pooled intercept correction per outcome
from pooled pre-treatment residuals across treated units (multisynth-like). This produces
\code{pooled_beta0} which is applied when computing unit-level effects.}

\item{nu}{Nonnegative ridge penalty for the pooled intercept correction (per outcome). Larger \code{nu}
shrinks the pooled intercept toward zero.}

\item{verbose}{Logical. If \code{TRUE}, prints progress.}

\item{standardize_outcomes}{Logical. If \code{TRUE}, standardizes each outcome block in the
stacked pre-treatment design using donor pre-treatment moments (to improve comparability
across outcomes). Standardization affects the weight-fitting objective only; treatment
effects are computed on the original outcome scale.}

\item{outcome_weights}{Optional numeric vector of length \code{M = length(Y_list)} giving
relative weights for each outcome block in the stacked pre-treatment objective. Larger values
put more emphasis on matching that outcome in pre-treatment periods. Defaults to equal weights.}

\item{time_weights}{Optional numeric vector of length \code{L} giving relative weights for the
\code{L} pre-treatment periods within each outcome block. Defaults to equal weights. A common
use is to emphasize recent pre-treatment periods.}

\item{intercept}{Character. Intercept handling in the weight-fitting objective. One of:
\describe{
\item{\code{"none"}}{No intercept projection; weights attempt to match both levels and trends.}
\item{\code{"global"}}{Project out a single intercept shared across all outcomes and pre-periods
in the stacked objective (equivalent to minimizing over \eqn{b} in \eqn{\|y - Xw - b\mathbf{1}\|_W^2}).}
\item{\code{"outcome"}}{Project out a separate intercept within each outcome block (recommended for
multi-outcome settings). This is equivalent to minimizing over \eqn{b_m} for each outcome block
in \eqn{\sum_m \|y^{(m)} - X^{(m)}w - b_m\mathbf{1}\|_{W_m}^2}.}
}}

\item{eps_sd}{Small positive constant used as numerical jitter in standardization to avoid division by
near-zero standard deviations (only relevant when \code{standardize_outcomes = TRUE}).}
}
\value{
A list with components:
\describe{
\item{weights}{Named list of donor weight vectors, one per treated unit.}
\item{donors}{Named list of donor index vectors, one per treated unit.}
\item{tau}{Numeric array of dimension \code{J x M x (K+1)} containing unit-level event-time
treatment effects, where \code{J = length(treated_units)} and \code{M = length(Y_list)}.}
\item{treated_units}{Integer vector of treated units used in estimation.}
\item{pooled_beta0}{NULL or numeric vector length \code{M} of pooled intercept adjustments.}
\item{pooled_adjustment}{Logical flag as passed in.}
\item{nu}{Penalty parameter used for pooled adjustment.}
}
}
\description{
Estimates donor weights and unit-level event-time treatment effects for multiple
outcomes in staggered adoption settings, using a stacked pre-treatment objective
across outcomes. Designed for scalability via donor screening and simplex solvers
(Frank--Wolfe). Optionally includes a pooled intercept adjustment (multisynth-like)
estimated from pooled pre-treatment residuals across treated units.
}
\details{
For each treated unit \code{j}, the estimator:
\enumerate{
\item Constructs a donor set \code{donors_j} by screening eligible donors and restricting to at most
\code{max_donors}.
\item Builds a stacked pre-treatment design \code{X_j} and target \code{y_j} by stacking the \code{L}
pre-treatment periods across the \code{M} outcomes.
\item Optionally projects out intercepts in the stacked objective via \code{intercept}.
\item Fits simplex-constrained weights \code{w_j} by minimizing a weighted ridge objective
\eqn{(y_j - X_j w)^\top W (y_j - X_j w) + \lambda\|w\|_2^2}, implemented by row pre-whitening.
\item Computes outcome-by-event-time treatment effects \code{tau[j,m,k]} using the fitted weights
(and optional pooled adjustment).
}

The returned unit-level effects can be exported to second-stage analyses (e.g., regressing
\code{tau[,m,1]} or average effects over \code{k=1..K} on unit covariates).
}
\examples{
set.seed(1)
N <- 300; T <- 120
Y1 <- matrix(rnorm(N*T), N, T)
Y2 <- matrix(rnorm(N*T), N, T)
treat_time <- rep(Inf, N); treat_time[1:60] <- sample(60:90, 60, replace = TRUE)

fit <- multiout_synth(
  Y_list = list(Y1, Y2),
  treat_time = treat_time,
  L = 20, K = 5,
  max_donors = 150,
  intercept = "outcome",
  outcome_weights = c(1, 1),
  time_weights = rep(1, 20),
  pooled_adjustment = FALSE,
  verbose = FALSE
)
dim(fit$tau)

}
